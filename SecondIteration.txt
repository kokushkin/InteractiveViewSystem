Необходимо обеспечить поддержку различных реализаций EventModel.
Обеспечим полиморфизм, заменив ссылки на EventModel, на IEventModel.
Аналогично IProcessModel.

Кто будет создавать эти объекты.

1)

Для создания объектов, нужна фабрика. (почему не шаблоном?)
Назовем ее EventsFactory.

Исходя из требований, будут нужны различные реализации фабрик, так что, 
фабрика реализует интерфейс IEventsFactory.

2) Будет создавать IProcessModel.
Конкретная реализация будет создавать нужный IEventModel.
Переопределяемая функция CreateItem

Это обязанность согласуется с назначением процесса, 
так что нет необходимости создавать "синтетические фабрики".

выбираем 2;


//-----------------------------

Process так же должен быть способен обновлять свои поля как и Event.
т.е. Process - это Event, отчасти, кроме названия полей

как этого достичь?

Назначить обязанности классам ItemViewModel и ListViewModel
и классам ItemModel и ListModel

И стоотв. интерфейсы.


ProcessViewModel, EventViewModel, ProcessModel и EventModel
 наследуются от соответствующих классов.

методы ItemViewModel, ListViewModel, например

public IEventModel GetEventModel();
public DetailEventViewModel(IEventModel model);

очевидно должны быть generic. Однако в качестве параметра 
не может быть поставлен наследник, и это бы сильно усложнило 
структуру => отказываемся от наследования.

Параметр будет содержать лишь особенности данных, соотв. предметной области.

PS.

Насчет очевидности genric.
Можно наследоваться от интерфейсов, и соответствующийх типов. 
И даже применить ковариантность для возвращаемых параметров,
если определить соответствующий интефейс еще выше.

Но для процесса тогда понадобится множественное наследование так что не вариант.


PS2. Есть еще возможность избавитья от шаблонов?
Агригировать общие классы такие как ItemModel в частные.
(в шаблонном варианте мы агрегируем частные в общие)

- засорять бизнес классы ненужной логикой

PS3. Аргегировать классы бзнес-объетов в  о бщие классы , без generic.
Сообщить от типе бизнес объекта агрегированного в общем классе модел,
для типа объекта агрегированнго во ViewModel не удастся.

останавлияваемся на варианте шаблонов.
кто будет создавать IItemDataViewModel,
IItemModel<IItemDataModel>, и т.д.
Поручаем это классу ModelsAndViewModelsCreator


//-----------------------------

